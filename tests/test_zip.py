import hashlib
import os
import tempfile

import pytest

from ricecooker.utils.zip import create_predictable_zip


# The MD5s in this object are generated by running this file as a script
# they should not be updated as they are now our baseline for what our predictable zip should produce
# so any changes to the implementation should not change these values, if they do, it's a bug.
TEST_CASES = {
    "nested_text": {
        "files": {"folder/nested.txt": "Nested content", "test.txt": "Hello World"},
        "expected_md5": "220f0d36a5150d3912a0eebee2738d80",  # Generated by running this file as a script
    },
    "reversed": {
        "files": {"b.txt": "content b", "a.txt": "content a"},
        "expected_md5": "5f3c72e2f32c5b7919cd6c31e5f169cd",  # Generated by running this file as a script
    },
    "binaryFiles": {
        "files": {
            "image.png": b"PNG\x89\x50\x4E\x47\x0D\x0A\x1A\x0A",
            "data.bin": bytes([0xFF, 0xD8, 0xFF, 0xE0]),
            "text.txt": "Mixed content",
        },
        "expected_md5": "18ba9ca5ba2ed25ada40111fcc055a82",  # Generated by running this file as a script
    },
    "nested_binary": {
        "files": {
            "folder/image.png": b"PNG\x89\x50\x4E\x47\x0D\x0A\x1A\x0A",
            "test.txt": "Hello World",
        },
        "expected_md5": "0fdfc3bd5b661ae3cde677d542426386",  # Generated by running this file as a script
    },
    "simple_binary": {
        "files": {"test.bin": bytes([0x00, 0x01, 0x02, 0x03])},
        "expected_md5": "461a08dc38d2b7dae48c2bc2e641b958",  # We'll generate this
    },
}


def create_test_files(files):
    temp_dir = tempfile.mkdtemp()
    for path, content in files.items():
        full_path = os.path.join(temp_dir, path.replace("/", os.sep))
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        mode = "wb" if isinstance(content, bytes) else "w"
        with open(full_path, mode) as f:
            f.write(content)
    return temp_dir


def generate_md5(temp_dir, entrypoint=None):
    zip_path = create_predictable_zip(temp_dir, entrypoint=entrypoint)
    with open(zip_path, "rb") as f:
        md5 = hashlib.md5(f.read()).hexdigest()
    os.remove(zip_path)
    return md5


def cleanup(temp_dir):
    for root, dirs, files in os.walk(temp_dir, topdown=False):
        for name in files:
            os.remove(os.path.join(root, name))
        for name in dirs:
            os.rmdir(os.path.join(root, name))
    os.rmdir(temp_dir)


@pytest.mark.parametrize("case_name,case", TEST_CASES.items())
def test_predictable_zip(case_name, case):
    temp_dir = create_test_files(case["files"])
    try:
        md5 = generate_md5(temp_dir, case.get("entrypoint"))
        assert md5 == case["expected_md5"], f"MD5 mismatch for {case_name}"
    finally:
        cleanup(temp_dir)


def test_order_independence():
    reversed_files = dict(reversed(list(TEST_CASES["reversed"]["files"].items())))
    temp_dir1 = create_test_files(TEST_CASES["reversed"]["files"])
    temp_dir2 = create_test_files(reversed_files)
    try:
        md5_1 = generate_md5(temp_dir1)
        md5_2 = generate_md5(temp_dir2)
        assert md5_1 == md5_2
    finally:
        cleanup(temp_dir1)
        cleanup(temp_dir2)


if __name__ == "__main__":
    for name, case in TEST_CASES.items():
        temp_dir = create_test_files(case["files"])
        md5 = generate_md5(temp_dir, case.get("entrypoint"))
        print(f"MD5 for {name}: {md5}")
        cleanup(temp_dir)
